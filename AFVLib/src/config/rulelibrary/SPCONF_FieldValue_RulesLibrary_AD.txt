<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE Rule PUBLIC "sailpoint.dtd" "../sailpoint.dtd">
<Rule name="SPCONF Field Value Rules Library" language="beanshell">

    <Source>
        <![CDATA[

		import java.sql.Connection;
		import java.sql.PreparedStatement;
		import java.sql.ResultSet;
		import java.text.DateFormat;
		import java.text.ParseException;
		import java.text.SimpleDateFormat;
		import java.util.ArrayList;
		import java.util.Arrays;
		import java.util.Calendar;
		import java.util.Date;
		import java.util.GregorianCalendar;
		import java.util.HashMap;
		import java.util.Hashtable;
		import java.util.Iterator;
		import java.util.List;
		import java.util.Locale;
		import java.util.Map;

		import javax.naming.Context;
		import javax.naming.NamingEnumeration;
		import javax.naming.NamingException;
		import javax.naming.directory.DirContext;
		import javax.naming.directory.InitialDirContext;
		import javax.naming.directory.SearchControls;
		import javax.naming.directory.SearchResult;

		import org.apache.commons.lang.time.DateUtils;
		import org.apache.commons.logging.Log;
		import org.apache.commons.logging.LogFactory;

		import sailpoint.api.PasswordGenerator;
		import sailpoint.api.PersistenceManager;
		import sailpoint.api.SailPointContext;
		import sailpoint.connector.Connector;
		import sailpoint.object.Application;
		import sailpoint.object.Custom;
		import sailpoint.object.Filter;
		import sailpoint.object.Identity;
		import sailpoint.object.Link;
		import sailpoint.object.QueryOptions;
		import sailpoint.object.ResourceObject;
		import sailpoint.tools.CloseableIterator;
		import sailpoint.tools.GeneralException;
		import sailpoint.tools.Util;
		import sailpoint.tools.xml.XMLReferenceResolver;
		
		private static Log loggerAD = LogFactory.getLog("rule.SP.FieldValue.RulesLibrary");

		private static SailPointContext context;

		private static boolean isDebugEnabled = loggerAD.isDebugEnabled();


		/**
		 * RFC2256: ISO-3166 country 2-letter code
		 * Example:
				c: FR
				c: UK
		 * @param context
		 * @param identity
		 * @param op
		 * @return
		 */
		public static Object getFV_Active_Directory_c_Rule(SailPointContext context, Identity identity, String op){
			return getFV_Active_Directory_c_Rule(context, identity, op, null);
		}

		/**
		 * RFC2256: ISO-3166 country 2-letter code (workCountry)
		 * Example:
				c: FR
				c: UK
		 * @param context
		 * @param identity
		 * @param op
		 * @param defaultValue
		 * @return
		 */
		public static Object getFV_Active_Directory_c_Rule(SailPointContext context, Identity identity, String op, Object defaultValue){
			loggerAD.trace("Enter AD c rule");
			Object c = null;
			if (null!=identity){
				c = identity.getAttribute("c");
			}else{
				loggerAD.trace("identity is null, returning defultValue");
			}
			c  = (null!=c?c:defaultValue);
			loggerAD.trace("Exit AD c rule: " + c);
			return c;
		}


		/**
		 * co is supposed to be the non code name for the country
		 * @param context
		 * @param identity
		 * @param op
		 * @return
		 */
		public Object getFV_Active_Directory__co_Rule(SailPointContext context, Identity identity, String op){
			return getFV_Active_Directory__co_Rule(context, identity, op, null);
		}

		/**
		 * co is supposed to be the non code name for the country
		 * @param context
		 * @param identity
		 * @param op - The value of the template attribute maps to the "op" argument in the method.
		 * @param defaultValue
		 * @return
		 */
		public Object getFV_Active_Directory__co_Rule(SailPointContext context, Identity identity, String op, Object defaultValue){
			loggerAD.trace("Enter getFV_Active_Directory__co_Rule");
			loggerAD.trace("defaultValue:: "+(String)defaultValue);

			Object co = null;
			if (null!=identity){
				co = identity.getAttribute("country");
			} else{
				loggerAD.trace("identity is null, returning defultValue");
			}

			co = null!=co?((String) co).trim():defaultValue;
			loggerAD.trace("Exit getFV_Active_Directory__co_Rule: " + co);

			return co;
		}



		public static Object getFV_Active_Directory_cn_Rule(SailPointContext context, Identity identity, String op) throws GeneralException {
			return getFV_Active_Directory_cn_Rule(context, identity, op, null);
		}

		/**
		 * RFC2256: common name(s) for which the entity is known by
		 * This is the X.500 commonName attribute, which contains a name of an object. If the object corresponds to a person, it is typically the person's full name.
		 * 
		 * This method will calculate the CN based on the user's firstname and lastname
		 * CN is of the format LastName, FirstName
		 * @param context
		 * @param identity
		 * @param op
		 * @return
		 * @throws GeneralException 
		 */
		public static Object getFV_Active_Directory_cn_Rule(SailPointContext context, Identity identity, String op, Object defaultValue) throws GeneralException{
			loggerAD.trace("Enter getFV_Active_Directory_cn_Rule cn rule");

			String cn = "";

			if (identity == null) {
				loggerAD.warn("Invalid Identity, returning defaulValue: "+defaultValue);
				return (null==defaultValue?cn:defaultValue);
			}

			String preferredName = (String) identity.getAttribute("PreferredName");
			//if PreferredName is available in IIQ, it should be used instead of the first name
			String firstName = (null!=preferredName&&!preferredName.equals(""))?preferredName:escapeADValues(identity.getFirstname());
			loggerAD.trace("First name: "+firstName);
			String lastName = escapeADValues(identity.getLastname());
			loggerAD.trace("Last name: "+lastName);
			cn = lastName + "\\, " + firstName ;

			//If need to check for uniqueness, uncomment the following code:
	//		Application appObj = context.getObject(Application.class, "%%AD_TARGET_NAME%%");
	//
	//		logger.trace("Checking for uniqueness in Application: "+"%%AD_TARGET_NAME%%");
	//		if (!isUniqueADName(appObj, "cn", cn)) {
	//			//if not unique, we will add a "2" to the cn value
	//			int ctr = 2;
	//			cn = firstName + "." + lastName + ctr;
	//
	//			//if cn2 not unique, it will add 1 until the method finds a unique cn value
	//			while (!isUniqueADName(appObj, "cn", cn)) {
	//				ctr++;
	//				cn = firstName + "." + lastName + ctr;
	//				logger.trace("Value " + cn + " was tested");
	//			}
	//		}
	//		context.decache(appObj);

			loggerAD.trace("Exit getFV_Active_Directory_cn_Rule2 cn rule: " + cn);
			return cn;
		}



		public static Object getFV_Active_Directory_cscPreferredName_Rule(SailPointContext context, Identity identity, String op){
			loggerAD.trace("Enter getFV_Active_Directory_cscPreferredName_Rule rule");
			String cscPreferredName = (String) identity.getAttribute("preferredName");
			String val;
			if (null!= cscPreferredName) {
				val = fixNulls(cscPreferredName);
			} else {
				val = "";
			}

			loggerAD.trace("Exit getFV_Active_Directory_cscPreferredName_Rule rule: " + val);
			return val;
		}

		/**
		 * RFC2798: identifies a department within an organization
		 * Code for department to which a person belongs. This can also be strictly numeric (e.g., 1234) or alphanumeric (e.g., ABC/123).
		 * @param context
		 * @param identity
		 * @param op
		 * @return
		 */
		public static Object getFV_Active_Directory_departmentNumber_Rule(SailPointContext context, Identity identity, String op){
			loggerAD.trace("Enter AD departmentNumber rule");
			String departmentNumber = (String) identity.getAttribute("companyCode");
			String val = fixNulls(departmentNumber);

			loggerAD.trace("Exit AD departmentNumber rule: " + val);
			return val;
		}

		/**
		 * RFC2256: descriptive information
		 * This attribute contains a human-readable description of the object.
		 * @param context
		 * @param identity
		 * @param op
		 * @return
		 */
		public static Object getFV_Active_Directory_description2_Rule(SailPointContext context, Identity identity, String op){
			loggerAD.trace("EntergetFV_Active_Directory_description_Rule");

			//DateFormat dateFormat = new SimpleDateFormat("E, dd MMM yyyy HH:mm");
			//Date date = new Date();
			//String val = "Not yet activated. Created on " + dateFormat.format(date);
			String val = "Created by IdentityIQ on "+new Date();
			loggerAD.trace("Exit getFV_Active_Directory_description_Rule: " + val);
			return val;
		}

		public static Object getFV_Active_Directory_description_Rule(SailPointContext context, Identity identity, String op){
			return getFV_Active_Directory_description_Rule(context, identity, op, null);
		}

		public static Object getFV_Active_Directory_description_Rule(SailPointContext context, Identity identity, String op, Object defaultValue){
			loggerAD.trace("Enter get Field Value AD->description for app Standard rule");

			Object description = null;
			if (null!=identity){
				String jobTitle = (String) identity.getAttribute("jobtitle");
				String employeeType = (String) identity.getAttribute("employeetype");
				String companyId = (String) identity.getAttribute("companyid");

				if(employeeType.equals("Employee")){
					description = jobTitle;
				}else{
					if(companyId.equals("598")) {
						description = jobTitle + " Humana";
					}else {
						description = jobTitle + " Contractor";
					}            
				}            
			}

			loggerAD.trace("Exit get Field Value AD->description for app Standard rule: " + description);
			return (null!=description?((String) description).trim():defaultValue);
		}

		/**
		 * RFC2798: preferred name to be used when displaying entries
		 * When displaying an entry, especially within a one-line summary list, it is useful to be able to identify a name to be used. 
		 * Since other attribute types such as 'cn' are multivalued, an additional attribute type is needed. 
		 * Display name is defined for this purpose.
		 * @param context
		 * @param identity
		 * @param op
		 * @return
		 */
		public static Object getFV_Active_Directory_displayName_Rule(SailPointContext context, Identity identity, String op){
			loggerAD.trace("Enter getFV_Active_Directory_displayName_Rulee");

			String val = "";
			String firstName = identity.getFirstname();
			firstName = fixNulls(firstName);
			String lastName = identity.getLastname();
			lastName = fixNulls(lastName);
			String middleName = (String) identity.getAttribute("middleName");
			middleName = fixNulls(middleName);
			String userType = (String) identity.getAttribute("userType");
			String displayName;

			if (middleName.equals("")) {
				displayName = lastName + ", " + firstName;
			} else {
				displayName = lastName + ", " + firstName + " " + middleName;
			}

			if (userType != null && userType.equals("SC")) {
				displayName = displayName + " - NONEMP";
			}

			val = fixNulls(displayName);

			loggerAD.trace("Exit getFV_Active_Directory_displayName_Rule: " + val);
			return val;
		}



		/**
		 * DN is calculated based on the OU mappings defined in the custom object
		 * 
		 * @param spcontext
		 *            - context for search
		 * @param identity
		 *            - identity
		 * @return - Full DN
		 * @throws GeneralException 
		 */
		public static Object  getFV_Active_Directory_DN_Rule(SailPointContext spcontext, Identity identity, String op) throws GeneralException {

			loggerAD.trace("Enter getFV_Active_Directory_DN_Rule");

			String CUSTOM_AD_MAPPINGS = "FD-ActiveDirectory-OU-Mappings";
			String KEY_SEARCH_ORDER = "searchOrder";
			String KEY_DEFAULT_OU = "defaultOU";
			String AND_SEPARATOR = "_";

			String dn = "";

			if (spcontext == null || identity == null) {
				loggerAD.warn("Invalid identity or context");
			}

			String cn = (String) getFV_Active_Directory_cn_Rule(spcontext, identity, op);
			String ou = "";

			// OU should be calucalated based on the filters provided in the custom object
			// The custom object will have the OU mappings and the search order
			// First match in the order will give the right ou - Once the OU is obtained
			// exit the loop

			List searchOrderList = (List) getValueFromCustomObject(spcontext, CUSTOM_AD_MAPPINGS, KEY_SEARCH_ORDER);

			loggerAD.debug("Search order defined in the custom object " + searchOrderList);

			// If the custom object is not valid - exit
			if (searchOrderList != null && !searchOrderList.isEmpty()) {
				for (Object searchAttributeOb : searchOrderList) {
					// Attribute from the search order
					String searchAttribute = (String) searchAttributeOb;
					// The custom object will have a key defined with the searchAttribute name defined
					// in the search order containing the possible OU combinations.
					String searchValue = "";
					// If there is no search attribute - continue to the next attribute
					if (Util.isNullOrEmpty(searchAttribute)) {
						loggerAD.warn("SearchAttribute is null in the list, moving to the next attribute");
						continue;
					}

					// Now we have the value from the identity cube
					// This value should be present in the map that contains the OU
					Map ouMap = (Map) getValueFromCustomObject(spcontext, CUSTOM_AD_MAPPINGS, searchAttribute);
					if (ouMap == null || ouMap.isEmpty()) {
						loggerAD.warn("ou mapping is null, moving to the next attribute");
						continue;
					}

					// Mulitple attribtues should be looked - to get the right OU
					if (searchAttribute.contains(AND_SEPARATOR)) {
						if (isDebugEnabled) {
							loggerAD.debug("Muliple attributes are to be looked. Generating the lookup value");
						}
						int count = 0;
						String[] searchAttributes = searchAttribute.split(AND_SEPARATOR);
						for (String attributeName : searchAttributes) {
							String attributeValue = identity.getStringAttribute(attributeName);
							if (count == 0) {
								searchValue = attributeValue;
							} else {
								searchValue = searchValue + AND_SEPARATOR + attributeValue;
							}
							count++;
						}
					} else {
						if (isDebugEnabled) {
							loggerAD.debug("Only one attribute is to be looked.");
						}
						searchValue = identity.getStringAttribute(searchAttribute);
					}

					if (isDebugEnabled) {
						loggerAD.debug("Using the search value " + searchValue);
					}

					// see if the value is present in the ou map
					// If the value is present - break the loop
					if (Util.isNotNullOrEmpty(searchValue) && ouMap.containsKey(searchValue)) {
						ou = (String) ouMap.get(searchValue);
						break;
					}
				}
			}
			// Check if the ou is null or not
			if (Util.isNullOrEmpty(ou)) {
				if (isDebugEnabled) {
					loggerAD.debug("No ou is defined in the mappings. Using the default ou.");
				}
				ou = (String) getValueFromCustomObject(spcontext, CUSTOM_AD_MAPPINGS, KEY_DEFAULT_OU);
			}

			// by this time , atleast a default ou should be populated, now generate the dn
			dn = "cn="+cn + "," + ou;
			if (isDebugEnabled) {
				loggerAD.debug("DN to use " + dn);
			}
			return dn;
		}

		public static Object getFV_Active_Directory_employeeID_Rule(SailPointContext context, Identity identity, String op){
			loggerAD.trace("Enter AD employeeID rule");
			String employeeID = identity.getName();
			String val = fixNulls(employeeID);

			loggerAD.trace("Exit AD employeeID rule: " + val);
			return val;
		}

		/**
		 * RFC2798: type of employment for a person
		 * Used to identify the employer to employee relationship. 
		 * Typical values used will be "Contractor", "Employee", "Intern", "Temp", "External", and "Unknown" but any value may be used.
		 * @param context
		 * @param identity
		 * @param op
		 * @return
		 */
		public static Object getFV_Active_Directory_employeeType_Rule(SailPointContext context, Identity identity, String op){
			loggerAD.trace("Enter AD employeeType rule");
			String employeeType = (String) identity.getAttribute("userType");
			String val = fixNulls(employeeType);

			loggerAD.trace("Exit AD employeeType rule: " + val);
			return val;
		}

		/**
		 * RFC2256: first name(s) for which the entity is known by
		 * The givenName attribute is used to hold the part of a person's name which is not their surname nor middle name.
		 * @param context
		 * @param identity
		 * @param op
		 * @return
		 */
		public static Object getFV_Active_Directory_givenName2_Rule(SailPointContext context, Identity identity, String op){
			loggerAD.trace("EntergetFV_Active_Directory_givenName_Rule");

			String firstName = identity.getFirstname();
			String val = fixNulls(firstName);

			loggerAD.trace("Exit getFV_Active_Directory_givenName_Rule: " + val);
			return val;
		}


		/*
		 *********givenName********
		 */
		public static Object getFV_Active_Directory_givenName_Rule(SailPointContext context, Identity identity, String op){
			return getFV_Active_Directory_givenName_Rule(context, identity, op, null);
		}

		public static Object getFV_Active_Directory_givenName_Rule(SailPointContext context, Identity identity, String op, Object defaultValue){
			loggerAD.trace("Enter Active_Directory APP firstname rule");

			Object firstname = defaultValue;
			if (null!=identity){
				firstname = identity.getFirstname();
			}
			loggerAD.trace("Exit Active_Directory APP firstname rule: " + firstname);
			return (null!=firstname?((String) firstname).trim():defaultValue);
		}

		public static Object getFV_Active_Directory_l_Rule(SailPointContext context, Identity identity, String op){
			loggerAD.trace("Enter AD l rule");
			String l = (String) identity.getAttribute("workCity");
			String val = fixNulls(l);

			loggerAD.trace("Exit AD l rule: " + val);
			return val;
		}

		/**
		 * RFC2256: initials of some or all of names, but not the surname(s).
		 * @param context
		 * @param identity
		 * @param op
		 * @return
		 */
		public static Object getFV_Active_Directory_initials_Rule(SailPointContext context, Identity identity, String op){
			loggerAD.trace("Enter getFV_Active_Directory_initials_Rule");
			String val;
			String middleName = (String) identity.getAttribute("middleName");
			middleName = fixNulls(middleName);
			if (middleName.length() > 0) {
				val = middleName.substring(0,1);
			} else {
				val = "";
			}
			loggerAD.trace("Exit getFV_Active_Directory_initials_Rule: " + val);
			return val;
		}


		public static Object getFV_Active_Directory_middleName_Rule(SailPointContext context, Identity identity, String op){
			loggerAD.trace("Enter getFV_Active_Directory_middleName_Rule");
			String middleName = (String) identity.getAttribute("middleName");
			String val = fixNulls(middleName);

			loggerAD.trace("Exit getFV_Active_Directory_middleName_Rule: " + val);
			return val;
		}

		/**
		 * 'RFC1274: mobile telephone number
		 * The Mobile Telephone Number attribute type specifies a mobile telephone number associated with a person. 
		 * Attribute values should follow the agreed format for international telephone numbers: i.e., "+44 71 123 4567".
		 * @param context
		 * @param identity
		 * @param op
		 * @return
		 */
		public static Object getFV_Active_Directory_mobile_Rule(SailPointContext context, Identity identity, String op){
			loggerAD.trace("Enter AD mobile rule");
			String mobile = (String) identity.getAttribute("mobilePhone");
			String val = fixNulls(mobile);

			loggerAD.trace("Exit AD mobile rule: " + val);
			return val;
		}

		/**
		 * RFC2459: legacy attribute for email addresses in DNs
		 * @param context
		 * @param identity
		 * @param op
		 * @return
		 */
		public static Object getFV_Active_Directory_mail_Rule(SailPointContext context, Identity identity, String op){
			return getFV_Active_Directory_mail_Rule(context, identity, op, null);
		}

		public static  Object getFV_Active_Directory_mail_Rule(SailPointContext context, Identity identity, String op, Object defaultValue){
			loggerAD.trace("Enter Active_Directory APP email rule");

			/* getUniqueValue checks if the Employee Id already exists in the User Id Hist table, if found it gets the email attribute value
			 * if none is found it generates a new one, checks it for duplicate and when a unique one is generated it updates the current Employe Id current row in the table
			 */
			String email = getUniqueValue(identity, "email");

			loggerAD.trace("Exit Active_Directory APP email rule: " + email);
			return (null!=email?email.trim():defaultValue);
		}


		/**
		 * RFC1274: DN of manager
		 * The Manager attribute type specifies the manager of an object represented by an entry.
		 * @param context
		 * @param identity
		 * @param op
		 * @return
		 * @throws GeneralException
		 */
		public static Object getFV_Active_Directory_manager_Rule(SailPointContext context, Identity identity, String op) throws GeneralException{
			return getFV_Active_Directory_manager_Rule(context, identity, op, null);
		}

		public static Object getFV_Active_Directory_manager_Rule(SailPointContext context, Identity identity, String op, Object defaultValue) throws GeneralException{
			loggerAD.trace("Enter get Field Value manager for Active_Directory rule");

			Object manager = defaultValue;
			if (null!=identity){
				Identity managerIdentity = identity.getManager();
				if (null!=managerIdentity) {
					Application application = context.getObjectByName(Application.class, "Active_Directory");
					Link managerAdLink = managerIdentity.getLink(application);
					manager = (null!=managerAdLink?managerAdLink.getNativeIdentity():null);
				}
			}
			loggerAD.trace("Exit get Field Value manager or Active_Directory rule - " + manager);
			return (null!=manager?manager:defaultValue);
		}

		public static Object getFV_Active_Directory_manager2_Rule(SailPointContext context, Identity identity, String op) throws GeneralException{
			loggerAD.trace("Enter AD manager rule");

			String val = "";

			// Retrieve DN directly from the manager's AD account
			Identity managerIdentity = identity.getManager();
			if (managerIdentity == null) {
				loggerAD.trace("No Manager found");
				return val;
			} else {
				String managerId = managerIdentity.getName();
				if (managerId==null || managerId.equals("")) {
					loggerAD.trace("No Manager Id found");
					return val;
				} else {

					QueryOptions ops = new QueryOptions();
					ops.setIgnoreCase(true);
					ops.addFilter(Filter.ignoreCase(Filter.eq("name", managerId)));

					int num = context.countObjects(Identity.class, ops);
					Identity manager = null;

					if (num == 1) {
						manager = context.getUniqueObject(Identity.class, Filter.and(ops.getRestrictions()));
					}

					if (manager == null) {
						return val;
					}

					val = (String) getLinkVal(context, manager, "%%AD_TARGET_NAME%%", "distinguishedName");

					loggerAD.trace("Exit AD manager rule: " + val);
					return val;
				}
			}
		}

		/**
		 * Calculate the manager dn based on the manager information
		 * Manager DN is populated on the Active directory link
		 * 
		 * @param spcontext
		 *            - context for performing search
		 * @param identity
		 *            - identity to work upon
		 * 
		 * @param- applicationName
		 *         - application name where the dn is present
		 */
		public static Object getFV_Active_Directory_managerDN_Rule(SailPointContext context, Identity identity, String applicationName)  {
			String managerDN = "";
			boolean isDebugEnabled = loggerAD.isDebugEnabled();

			if (context == null || identity == null) {
				loggerAD.warn("context or identity to look for is not valid.");
				return managerDN;
			}

			// Get the manager present on the cube
			Identity manager = identity.getManager();
			if (manager == null) {
				loggerAD.warn("No manager is defined.");
				return managerDN;
			}

			if (isDebugEnabled) {
				loggerAD.debug("Manager is present for identity " + identity.getName() + ". Will search for the DN on the link.");
			}

			// Filter list
			List andFilterList = new ArrayList();
			andFilterList.add(Filter.eq("identity.name", manager.getName()));
			andFilterList.add(Filter.eq("application.name", applicationName));
			andFilterList.add(Filter.eq("displayName", manager.getName()));

			// Return attributes
			List returnAttributes = new ArrayList();
			returnAttributes.add("nativeIdentity");

			// Define Queryoptions for performing a search
			QueryOptions linkQo = new QueryOptions();
			linkQo.addFilter(Filter.and(andFilterList));
			try {
				// Search for the link
				Iterator linkIter = context.search(Link.class, linkQo, returnAttributes);
				if (linkIter.hasNext()) {
					managerDN = (String) linkIter.next();
					if (isDebugEnabled) {
						loggerAD.debug("Assigning manager " + managerDN + "for identity " + identity.getName());
					}
				}
			} catch (GeneralException e) {
				loggerAD.error("Error while searching for manager dn. " + e.getMessage());
				e.printStackTrace();
			}
			return managerDN;
		}

		/**
		 * RFC2256: member of a group'
		 * @param context
		 * @param identity
		 * @param op
		 * @return
		 */
		public static Object getFV_Active_Directory_memberOf_Rule(SailPointContext context, Identity identity, String op){
			return getFV_Active_Directory_memberOf_Rule(context, identity, op, null);
		}

		public static Object getFV_Active_Directory_memberOf_Rule(SailPointContext context, Identity identity, String op, Object defaultValue){
			loggerAD.trace("Enter get Field Value memberOf for app Active_Directory rule");

			Object memberOf = null;
			if (identity != null){
				memberOf = getAppAttribute(context, identity, "Active_Directory", "memberOf");
				loggerAD.debug("Original memberOf: " + memberOf);
				if(memberOf == null || !(memberOf instanceof List)){
					memberOf = new ArrayList();
				}
				memberOf.add("CN=CTX-Test,OU=Citrix,OU=Groups,OU=Concentra,ou=demo,dc=seri,dc=sailpointdemo,dc=com");
			}
			loggerAD.debug("Exit get Field Value memberOf for app Active_Directory rule: " + memberOf);
			loggerAD.trace("Exit get Field Value memberOf for app Active_Directory rule");
			return ((memberOf!=null)?memberOf:defaultValue);
		}

		public static Object getFV_Active_Directory_memberOf2_Rule(SailPointContext context, Identity identity, String op){
			loggerAD.trace("Enter AD memberOf rule");
			List memberOfList = new ArrayList();
			String group1="%%AD_TOP_LEVEL_DN%%";
			String group2="%%AD_TOP_LEVEL_DN%%";
			memberOfList.add(group1);
			memberOfList.add(group2);
			loggerAD.trace("Exit AD memberOf rule: " + memberOfList);
			return memberOfList;
		}

		/**
		 * The name attribute type is the attribute supertype from which string attribute types typically used for naming may be formed. It is unlikely that values of this type itself will occur in an entry. 
		 * LDAP server implementations which do not support attribute subtyping need not recognize this attribute in requests. 
		 * Client implementations MUST NOT assume that LDAP servers are capable of performing attribute subtyping.
		 * @param context
		 * @param identity
		 * @param str
		 * @return
		 */
		public static Object getFV_Active_Directory_Name_Rule(SailPointContext context, Identity identity, String op) {
			loggerAD.trace("Enter getFV_Active_Directory_Name_Rule rule");
			String val = identity.getName();
			loggerAD.trace("Exit getFV_Active_Directory_Name_Rule rule: " + val);
			return val;
		}



		/**
		 * 
		 * @param context
		 * @param identity
		 * @param op
		 * @return
		 */
		public static Object getFV_Active_Directory_password_Rule(SailPointContext context, Identity identity, String op){
			return getFV_Active_Directory_password_Rule(context, identity, op, null);
		}

		public static Object getFV_Active_Directory_password_Rule(SailPointContext context, Identity identity, String op, Object defaultValue){
			loggerAD.trace("Enter get Field Value AD->password for app Standard rule");

			Object password = null;
			if (null!=identity){
				String appName = "Active_Directory";
				try {
					PasswordGenerator pg = new PasswordGenerator(context);

					loggerAD.debug(" generatePolicyPassword : id " + identity.getName() + " and app: " + appName);
					Application app = (Application) context.getObjectByName(Application.class, appName);
					password = pg.generatePassword(identity, app);                 
				} catch (Exception e){
					loggerAD.error("Exception " + e.toString());
				}
			}

			loggerAD.trace("Exit get Field Value AD->password for app Standard rule: " + password);
			return (null!=password?((String) password).trim():defaultValue);
		}

		/**
		 * Azure Active Directory Application
		 * <AllowedValuesDefinition>
				<Value>
				  <List>
					<String>DisablePasswordExpiration</String>
					<String>DisableStrongPassword</String>
					<String>DisablePasswordExpiration, DisableStrongPassword</String>
				  </List>
				</Value>
			  </AllowedValuesDefinition>
		 * @param context
		 * @param identity
		 * @param str
		 * @return
		 */
		public static Object getFV_Active_Directory_PasswordPolicies_Rule(SailPointContext context, Identity identity, String op) {
			loggerAD.trace("Enter getFV_Active_Directory_PasswordPolicies_Rule rule");
			List values = new ArrayList();
			values.add("DisablePasswordExpiration");
			values.add("DisableStrongPassword");
			values.add("DisablePasswordExpiration, DisableStrongPassword");

			Iterator types=values.iterator();
			while (types.hasNext()) {
				loggerAD.trace("Active_Directory_PasswordPolicies_Rule AllowedValue:: " + (String)types.next());
			}

			loggerAD.trace("Exit getFV_Active_Directory_PasswordPolicies_Rule :" + values.size() +" allowed values.");
			return values;
		}

		//TODO: Define which value to return
		/**
		 * 
		 * @param context
		 * @param identity
		 * @param str
		 * @return
		 */
		public static Object getFV_Active_Directory_sAMAccountName_Rule(SailPointContext context, Identity identity, String op) {
			loggerAD.trace("Enter getFV_Active_Directory_sAMAccountName_Rule rule");
			String val = identity.getName();
			String sAMAccountName = (String) identity.getAttribute("userId");

			loggerAD.trace("Exit getFV_Active_Directory_sAMAccountName_Rule rule: " + val);
			return val;
		}

		public static Object getFV_Active_Directory_sAMAccountType_Rule(SailPointContext context, Identity identity, String op) {
			loggerAD.trace("Enter getFV_Active_Directory_sAMAccountType_Rule rule");
			String val = (String) identity.getAttribute("sAMAccountType");
			loggerAD.trace("Exit getFV_Active_Directory_sAMAccountType_Rule rule: " + val);
			return val;
		}



		/**
		 * RFC2256: last (family) name(s) for which the entity is known by
		 * This is the X.500 surname attribute, which contains the family name of a person.
		 * @param context
		 * @param identity
		 * @param str
		 * @return
		 */
		public static Object getFV_Active_Directory_sn_Rule(SailPointContext context, Identity identity, String op){
			return getFV_Active_Directory_sn_Rule(context, identity, op, null);
		}

		public static Object getFV_Active_Directory_sn_Rule(SailPointContext context, Identity identity, String op, Object defaultValue){
			loggerAD.trace("Enter Active_Directory APP lastname rule");

			Object lastname = defaultValue;
			if (null!=identity){
				lastname = identity.getLastname();
			}
			loggerAD.trace("Exit Active_Directory APP lastname rule: " + lastname);
			return (null!=lastname?((String) lastname).trim():defaultValue);
		}

		/**
		 * RFC1274: user identifier
		 * @param context
		 * @param identity
		 * @param str
		 * @return
		 */
		public static Object getFV_Active_Directory_UID_Rule(SailPointContext context, Identity identity, String op) {
			loggerAD.trace("Enter getFV_Active_Directory_UID_Rule ");
			String val = (String) identity.getAttribute("uid");
			loggerAD.trace("Exit getFV_Active_Directory_UID_Rule : " + val);
			return val;
		}





		/******************************************************************************
		UTILITIES
		 ******************************************************************************/

		public String verifyNull(Object o){
			if(o != null){
				return o.toString();
			}else{
				return "";
			}

		}

		/***********************************************************************
		Check for uniqueness of AD naming attribute against a given AD application,
		verified by using a copy of the connector.
		 ************************************************************************/

		public static Boolean isUniqueADName(Application application, String attName, String attValue) {
			XMLReferenceResolver context;
			loggerAD.trace("Entering isUniqueADName");
			Boolean unique = true;

			// Make a copy of the AD application
			Application appCopy = (Application) application.deepCopy(context);
			String appConnName = appCopy.getConnector();

			// Get the domain DN and use this as the searchDN so that we search the entire domain
			String searchDN = appCopy.getAttributes().getMap().get("domainSettings").get(0).get("domainDN");

			List dnList = new ArrayList();
			Map setupMap = new HashMap();
			setupMap.put("iterateSearchFilter", "(" + attName +  "=" + attValue + ")");
			setupMap.put("searchDN", searchDN);

			dnList.add(0, setupMap); // This takes the map we just changed and adds it back to the list in place of the map that was there.
			appCopy.setAttribute("searchDNs", dnList); // Add the list back to the app copy.
			appCopy.setAttribute("referral", "ignore");
			appCopy.setAttribute("useHasMoreElements", true);
			appCopy.setCustomizationRule(null);

			Connector appConnector = sailpoint.connector.ConnectorFactory.getConnector(appCopy, null);
			CloseableIterator iterator = appConnector.iterateObjects("account", null, null);

			try {
				if (iterator != null && iterator.hasNext() ) {
					if(iterator.hasNext()) {
						ResourceObject user = (ResourceObject) iterator.next();
						unique = false;
					}
				}

			} finally {
				if ( iterator != null ) iterator.close();
			}
			loggerAD.trace("Exiting isUniqueADName");
			((PersistenceManager) context).decache(appCopy);
			return unique;
		}

		public Boolean isUniqueEmail(String mailNickname, String shortName) {
			loggerAD.trace("Entering isUniqueEmail");
			Boolean unique = null;

			Connection dbCxn = null;
			try {
				dbCxn = context.getConnection();
			} catch (Exception ex) {
				String errMsg = "Error while connecting to database";
				loggerAD.error(errMsg);
				loggerAD.error(ex);
				return unique;
			}

			loggerAD.debug("Successfully connected to database");

			try {

				String emailAddress = mailNickname + "@%%COMPANY_MAIL_ALIAS%%";

				String sqlQuery = "SELECT ShortName FROM email_address WHERE EmailAddress = ?";

				PreparedStatement prStmt = dbCxn.prepareStatement(sqlQuery);
				prStmt.setString(1, emailAddress);

				ResultSet rs = prStmt.executeQuery();
				while ( (null != rs) && (rs.next()) ) {
					if (Util.nullSafeEq(rs.getString("ShortName"), shortName)) {
						unique = false;
					}
				}
				// ResultSets must be closed just like JDBC connections and cursors.
				rs.close();
				prStmt.close();

				if (unique == null) {
					unique = true;
					loggerAD.debug("Email address "+emailAddress+" is unique");
				} else {
					loggerAD.debug("Email address "+emailAddress+" is not unique");
					unique = false;
				}

			} catch (Exception ex) {

				loggerAD.error(ex);

			}

			loggerAD.trace("Exiting isUniqueEmail");
			return unique;
		}


		public Boolean isUniqueLDSync(String mailNickname,String searchOU) throws GeneralException, NamingException {
			loggerAD.trace("Entering isUniqueLDSync");
			String emailAddress = mailNickname + "@%%COMPANY_MAIL_ALIAS%%";
			Hashtable env = new Hashtable();
			String encryptedPassword = "%%LDSYNC_PASSWORD%%";
			String decryptedPassword = context.decrypt(encryptedPassword);
			env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
			env.put(Context.PROVIDER_URL, "%%LDSYNC_URL%%");
			env.put(Context.SECURITY_AUTHENTICATION, "simple");
			env.put(Context.SECURITY_PRINCIPAL, "%%LDSYNC_PRIVILEGED_USER%%");
			env.put(Context.SECURITY_CREDENTIALS, decryptedPassword);
			env.put("java.naming.ldap.version","3");

			DirContext ctx = new InitialDirContext(env);
			SearchControls searchControls = new SearchControls();
			searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);
			//searchControls.setCountLimit(10);
			NamingEnumeration<SearchResult> namingEnumeration = ctx.search(searchOU, "(mail="+emailAddress+")", new Object[]{}, searchControls);

			if (namingEnumeration.hasMore()) {
				ctx.close();
				loggerAD.trace("email address was found in LDSync");
				return false;
			} else {
				loggerAD.trace("email address was not found in LDSync");
				ctx.close();
				return true;
			}
		}

		public static Object getLinkVal(SailPointContext context, Identity identity, String appName, String attrName) throws GeneralException{
			loggerAD.trace("Enter getLinkVal");
			Object val = "";

			loggerAD.trace("appName: " + appName);
			loggerAD.trace("attrName: " + attrName);

			Link link = getSafeLink(context, identity, appName);

			if (link != null){
				val = link.getAttribute(attrName);

				if (val != null){
					if (val instanceof String){
						val = ((String) val).trim();
					}
				} else {
					val = "";
				}

			} else {
				loggerAD.warn("No link found for appName: " + appName);
			}

			loggerAD.trace("Exit getLinkVal: " + val);
			return val;
		}

		public static Link getSafeLink(SailPointContext context, Identity identity, String appName) throws GeneralException{
			Application app = context.getObjectByName(Application.class, appName);
			Link link = identity.getLink(app);

			if (link == null){
				link = new Link();
			}

			context.decache(app);

			return link;
		}


		public Link getLinkByNativeIdentity(SailPointContext context, String application, String nativeIdentity) throws GeneralException {
			loggerAD.trace("Enter getLinkByNativeIdentity");

			Link val = null;

			QueryOptions qo = new QueryOptions();
			qo.addFilter(Filter.eq("application.name", application));
			qo.addFilter(Filter.like("nativeIdentity", "CN="+nativeIdentity, Filter.MatchMode.START));
			Iterator it = context.search(Link.class, qo);
			if(it.hasNext()) {
				val = (Link) it.next();
			}

			loggerAD.trace("Exit getLinkByNativeIdentity: " + val);
			return val;
		}

		public static String escapeADValues(String strIn) {
			String val = strIn;
			loggerAD.trace("value passed to escapeADValues=" + val);
			if (strIn.indexOf(",") > -1) {
				val = val.replace(",","\\,");
			}
			val = val.replaceFirst("\\s++$","");
			loggerAD.trace("value returned from escapeADValues=" + val);
			return val;
		}


		public static String fixNulls(String strIn) {
			String val = strIn;
			loggerAD.trace("value passed to fixNulls=" + val);
			if (strIn==null) {
				val = "";
			}
			val = val.replaceFirst("\\s++$","");
			loggerAD.trace("value returned from fixNulls=" + val);
			return val;
		}

		/**
		 * Method to get the value from the custom object for a given key
		 * 
		 * @param spContext
		 *            - context to use for the search
		 * @param customObjectName
		 *            - custom object name to use
		 * @param key
		 *            - key to search for
		 * @return - key value , returns null if no match or errors found
		 */
		static Object getValueFromCustomObject(SailPointContext spContext, String customObjectName,
				String key) {

			// Log level
			boolean isDebugEnabled = loggerAD.isDebugEnabled();

			// Flag to see if the input parameters are valid or not
			boolean isValid = true;

			// Key values to return
			Object value = null;

			// Check if the customobjectname to look for is empty or not
			if (Util.isNullOrEmpty(customObjectName)) {
				loggerAD.error("Custom objet name to look for is not provided.");
				isValid = false;
			}

			// Check the context provided
			if (spContext == null) {
				loggerAD.error("Sailpointcontext is not provided.");
				isValid = false;
			}

			// Check the key provided
			if (Util.isNullOrEmpty(key)) {
				loggerAD.error("Key to look for in the custom object is not provided.");
				isValid = false;
			}

			// If all the input parameters are valid, go for a search
			if (isValid) {
				// Validate the custom object existence in the system
				QueryOptions customQo = new QueryOptions();
				customQo.addFilter(Filter.eq("name", customObjectName));
				Custom custom = null;
				try {
					// Check for the object presence
					int count = spContext.countObjects(Custom.class, customQo);
					// If the custom object is found, look for the key existence
					if (count == 1) {
						custom = spContext.getObjectByName(Custom.class, customObjectName);
						// If the key is present get the value
						if (custom.containsAttribute(key)) {
							value = custom.get(key);
						} else {
							loggerAD.error(
									"Key " + key + " is not present in " + customObjectName);
						}
					} else {
						loggerAD.error(
								"No custom object with the name " + customObjectName + " is found in the system.");
					}

				} catch (GeneralException e) {
					e.printStackTrace();
					loggerAD.error("Error searching for key in the custom object." + e.getMessage());
				} finally {
					// Decache the objects from the cache
					if (spContext != null && custom != null) {
						try {
							spContext.decache(custom);
						} catch (GeneralException e) {
							e.printStackTrace();
							loggerAD.error("Error decaching the context." + e.getMessage());
						}
					}
				}
			}
			return value;
		}

		public Date convertStringToDate(String dateValue, String dateFormat) throws ParseException {
			dateValue = (dateValue.indexOf(":")!=-1 ? dateValue : dateValue + " 00:00:00");
			DateFormat formatter = new SimpleDateFormat(dateFormat, Locale.ENGLISH);
			Date newDate = DateUtils.truncate(formatter.parse(dateValue), Calendar.DATE);
			return(newDate);
		}

		public Date calcFutureDate(int iDays, String dateFormat) {
			loggerAD.trace("Enter calcFutureDate - " + iDays);

			Calendar cal = Calendar.getInstance();
			cal.setTime(DateUtils.truncate(new Date(), Calendar.DATE));
			cal.add(Calendar.DATE, iDays);
			Date futureDt = cal.getTime();

			loggerAD.debug("Future Date: " + (new SimpleDateFormat(dateFormat, Locale.ENGLISH).format(futureDt)));
			loggerAD.trace("Exit calcFutureDate - " + futureDt);
			return(futureDt);
		}


		public Link getSafeLink(Identity identity, String appName) throws GeneralException{
			Application app = context.getObjectByName(Application.class, appName);
			Link link = identity.getLink(app);

			if (link == null){
				link = new Link();
			}

			context.decache(app);
			return link;
		}


		private static Object getAppAttribute(SailPointContext context2, Identity identity, String string, String string2) {
			// TODO Auto-generated method stub
			return null;
		}

		private static String getUniqueValue(Identity identity, String string) {
			// TODO Auto-generated method stub
			return null;
		}

	]]>
    </Source>
</Rule>